# Copyright 2025 Thousand Brains Project
# Copyright 2023 Numenta Inc.
#
# Copyright may exist in Contributors' modifications
# and/or contributions to the work.
#
# Use of this source code is governed by the MIT
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT.

"""Evaluation experiments using pretrained models.

This module defines a suite of evaluation experiments using pretrained models
generated by `dmc_pretraining_experiments.py`. The core experiments are
 - `dist_agent_1lm`
 - `touch_agent_1lm`
 - `dist_agent_1lm_nohyp`
 - `touch_on_dist`
 - `dist_on_touch`
 - `dist_agent_2lm`
 - `dist_agent_5lm`
 - `dist_agent_9lm`
 - `dist_agent_10lm`

These base experiments test on the same 77 YCB object, 14 rotation scheme used
to pretrain the loaded models. Each of these models may have counterparts with
combinations of noise and random object rotations. For example, for `dist_agent_1lm`,
we also have `dist_agent_1lm_noise` and `dist_agent_1lm_randrot`, and
`dist_agent_1lm_randrot_noise`. Furthermore, each of these has a variant that
evaluates the corresponding `_10distinctobj` pretrained model and tests
on the DISTINCT_OBJECTS dataset. These `_10distinctobj` variants are generated
automatically as a convenience. Other variants-creating functions have default
arguments they won't work for every experiment, so noise/randrot variants need to be
created manually.

Some differences between these configs and benchmarks:
 - Unless otherwise specified, they test on all 77 YCB objects.
 - Experiments have 14 epochs, so each object is viewed from 14 angles regardless of
   whether objects are in standard or random rotations.

On style: Unlike `ycb_experiments.py`, this often prefers functions to return configs
over copying and modifying them (for the most part). For example, we have the functions
`get_fc_dist_patch_config()` and `get_fc_surf_patch_config()` which return
default feature-change sensor module configs.

This approach has two main benefits:

 1. Make settings easier to find. Rather than following a chain of copied configs
    back to find which sensor or learning module an experiment uses, we can just look
    at the function that returns the config. In this way, the functions are an easy
    way to look up defaults.
 2. Parameterize configs. This is especially useful when creating multi-LM
    experiments or deleting color information from sensor or learning modules in the
    case of touch-only (no color) experiments.

The config 'getter'functions defined here are
 - `get_dist_evidence_lm_config`
 - `get_surf_evidence_lm_config`
 - `get_fc_dist_patch_config`
 - `get_fc_surf_patch_config`
 - `get_view_finder_config`
 - `get_dist_motor_config`
 - `get_surf_motor_config`

At present, all experiments use `EvidenceGraphLM` learning modules, `FeatureChangeSM`
sensor modules.

The goal-state-driven motor system ("hypothesis-testing policy") is used unless a
config explicitly modifies this (e.g. `dist_agent_1lm_nohyp`).

We also have functions to generate experiment variants with sensor noise, random
rotations, or operate on the DISTINCT_OBJECTS dataset.
 - `make_noise_variant`
 - `make_randrot_variant`
 - `make_randrot_noise_variant`
 - `make_10distinctobj_variant`

Note that configs generated with `make_10distinctobj_variant` will load the
pretrained model that has the same name but with the "_10distinctobj" suffix. It
will not load the model trained on all 77 objects.

The variant-producing functions add suffixes to the logging config `run_name`.
For consistency, the following order of suffixes is preferred: `_randrot`, `_noise`,
`_10distinctobj`. Other conventions/expectations here:
 - The logging config's `run_name` should be set and match the experiment key.
 - The logging config's `output_dir` should be set to `OUTPUT_DIR`.

This module also has a few conveniences that add to or modify configs.
 - A 10-distinct object variant is automatically generated for every config.
 - Unused (but required) `train_dataloader_class` and `train_dataloader`
   items are added to configs automatically.
 - Experiments are checked to make sure no two configs have the same `output_dir` /
   `run_name` pair to ensure there is no conflict in output paths.
 - Logging can be modified or disabled depending on global variables (see below).
"""

import copy
import os
from pathlib import Path

import numpy as np
from tbp.monty.frameworks.config_utils.config_args import (
    MontyArgs,
    MotorSystemConfigCurInformedSurfaceGoalStateDriven,
    MotorSystemConfigInformedGoalStateDriven,
    ParallelEvidenceLMLoggingConfig,
    PatchAndViewMontyConfig,
    SurfaceAndViewMontyConfig,
    get_cube_face_and_corner_views_rotations,
    make_multi_lm_monty_config,
)
from tbp.monty.frameworks.config_utils.make_dataset_configs import (
    EnvironmentDataloaderPerObjectArgs,
    EvalExperimentArgs,
    PatchViewFinderMountHabitatDatasetArgs,
    PredefinedObjectInitializer,
    RandomRotationObjectInitializer,
    SurfaceViewFinderMountHabitatDatasetArgs,
    make_multi_sensor_habitat_dataset_args,
)
from tbp.monty.frameworks.environments import embodied_data as ED
from tbp.monty.frameworks.environments.ycb import DISTINCT_OBJECTS, SHUFFLED_YCB_OBJECTS
from tbp.monty.frameworks.experiments import MontyObjectRecognitionExperiment
from tbp.monty.frameworks.loggers.monty_handlers import ReproduceEpisodeHandler
from tbp.monty.frameworks.models.evidence_matching import (
    EvidenceGraphLM,
    MontyForEvidenceGraphMatching,
)
from tbp.monty.frameworks.models.goal_state_generation import (
    EvidenceGoalStateGenerator,
)
from tbp.monty.frameworks.models.sensor_modules import (
    DetailedLoggingSM,
    FeatureChangeSM,
)

from .common import PRETRAIN_DIR, RANDOM_ROTATIONS_5, RESULTS_DIR

# Specify defaults here

# - Logging
PYTHON_LOG_LEVEL = "WARNING"
LOG_WANDB = True
WANDB_GROUP = "dmc"
LOG_REPRODUCE_EPISODES = False

# - Experiment and Monty args
MAX_TOTAL_STEPS = 10_000
MIN_EVAL_STEPS = 20
MAX_EVAL_STEPS = 500

# - Define testing rotations. Views from enclosing cube faces plus its corners.
TEST_ROTATIONS = get_cube_face_and_corner_views_rotations()


# ------------------------------------------------------------------------------
# Getter functions for learning modules, sensor modules, and motor configs.
# ------------------------------------------------------------------------------


def get_dist_evidence_lm_config(
    sensor_module_id: str = "patch",
    max_nneighbors: int = 5,
    color: bool = True,
) -> dict:
    """Get default distant evidence learning module config for evaluation.

    Args:
        sensor_module_id: ID of the sensor module this LM is associated with.
        max_nneighbors: Maximum number of neighbors to consider when matching features.
        color: Whether to include color (HSV) features in matching.

    Returns:
        dict: Learning module configuration with EvidenceGraphLM class and arguments
              including matching tolerances, feature weights, and goal state settings.
    """
    out = dict(
        learning_module_class=EvidenceGraphLM,
        learning_module_args=dict(
            max_match_distance=0.01,  # =1cm
            tolerances={
                sensor_module_id: {
                    "hsv": np.array([0.1, 0.2, 0.2]),
                    "principal_curvatures_log": np.ones(2),
                }
            },
            feature_weights={
                sensor_module_id: {
                    "hsv": np.array([1, 0.5, 0.5]),
                }
            },
            # use_multithreading=False,
            # Most likely hypothesis needs to have 20% more evidence than the others
            # to be considered certain enough to trigger a terminal condition (match).
            x_percent_threshold=20,
            # look at 10 closest features stored in the search radius at most.
            max_nneighbors=max_nneighbors,
            # Update all hypotheses with evidence > x_percent_threshold (faster)
            evidence_update_threshold="x_percent_threshold",
            # NOTE: Currently not used when loading pretrained graphs.
            max_graph_size=0.3,  # 30cm
            num_model_voxels_per_dim=100,
            # Goal state generator which is used for model-based action suggestions.
            gsg_class=EvidenceGoalStateGenerator,
            gsg_args=dict(
                # Tolerance(s) when determining goal-state success
                goal_tolerances=dict(
                    location=0.015,  # distance in meters
                ),
                # Number of necessary steps for a hypothesis goal-state to be considered
                min_post_goal_success_steps=5,
                desired_object_distance=0.03,
            ),
        ),
    )
    if not color:
        out["learning_module_args"]["tolerances"][sensor_module_id].pop("hsv")
        out["learning_module_args"]["feature_weights"][sensor_module_id].pop("hsv")

    return out


def get_surf_evidence_lm_config(
    sensor_module_id: str = "patch",
    max_nneighbors: int = 5,
    color: bool = True,
) -> dict:
    """Get default surface evidence learning module config.

    Args:
        sensor_module_id: ID of the sensor module this LM receives input from.
        max_nneighbors: Maximum number of neighbors to consider when matching features.
        color: Whether to include color (HSV) features.

    Returns:
        dict: Learning module config dictionary containing class and args.
    """
    out = dict(
        learning_module_class=EvidenceGraphLM,
        learning_module_args=dict(
            max_match_distance=0.01,  # =1cm
            tolerances={
                sensor_module_id: {
                    "hsv": np.array([0.1, 0.2, 0.2]),
                    "principal_curvatures_log": np.ones(2),
                }
            },
            feature_weights={
                sensor_module_id: {
                    "hsv": np.array([1, 0.5, 0.5]),
                }
            },
            # Most likely hypothesis needs to have 20% more evidence than the others
            # to be considered certain enough to trigger a terminal condition (match).
            x_percent_threshold=20,
            # look at 10 closest features stored in the search radius at most.
            max_nneighbors=max_nneighbors,
            # Update all hypotheses with evidence > x_percent_threshold (faster)
            evidence_update_threshold="x_percent_threshold",
            # NOTE: Currently not used when loading pretrained graphs.
            max_graph_size=0.3,  # 30cm
            num_model_voxels_per_dim=100,
            # Goal state generator which is used for model-based action suggestions.
            gsg_class=EvidenceGoalStateGenerator,
            gsg_args=dict(
                # Tolerance(s) when determining goal-state success
                goal_tolerances=dict(
                    location=0.015,  # distance in meters
                ),
                # Number of necessary steps for a hypothesis goal-state to be considered
                min_post_goal_success_steps=5,
                desired_object_distance=0.025,
            ),
        ),
    )
    if not color:
        out["learning_module_args"]["tolerances"][sensor_module_id].pop("hsv")
        out["learning_module_args"]["feature_weights"][sensor_module_id].pop("hsv")

    return out


def get_dist_patch_config(
    sensor_module_id: str = "patch",
    color: bool = True,
) -> dict:
    """Get default feature-change sensor module config for distant agent.

    Args:
        sensor_module_id (str, optional): ID for the sensor module. Defaults to "patch".
        color (bool, optional): Whether to include color features. Defaults to True.

    Returns:
        dict: Configuration dictionary containing:
            - sensor_module_class: The FeatureChangeSM class
            - sensor_module_args: Dict of arguments including features list,
              delta thresholds, and other sensor module settings
    """
    out = dict(
        sensor_module_class=FeatureChangeSM,
        sensor_module_args=dict(
            sensor_module_id=sensor_module_id,
            features=[
                # morphological features (necessarry)
                "pose_vectors",
                "pose_fully_defined",
                # non-morphological features (optional)
                "on_object",
                "principal_curvatures_log",
                "hsv",
            ],
            delta_thresholds={
                "on_object": 0,
                "distance": 0.01,
            },
            surf_agent_sm=False,
            save_raw_obs=False,
        ),
    )
    if not color:
        out["sensor_module_args"]["features"].remove("hsv")
    return out


def get_surf_patch_config(
    sensor_module_id: str = "patch",
    color: bool = True,
) -> dict:
    """Get default feature-change sensor module config for surface agent.

    Args:
        sensor_module_id (str, optional): ID for the sensor module. Defaults to "patch".
        color (bool, optional): Whether to include color features. Defaults to True.

    Returns:
        dict: Configuration dictionary containing:
            - sensor_module_class: The FeatureChangeSM class
            - sensor_module_args: Dict of arguments including features list,
              delta thresholds, and other sensor module settings
    """
    out = dict(
        sensor_module_class=FeatureChangeSM,
        sensor_module_args=dict(
            sensor_module_id=sensor_module_id,
            features=[
                # morphological features (necessarry)
                "pose_vectors",
                "pose_fully_defined",
                "on_object",
                # non-morphological features (optional)
                "object_coverage",
                "min_depth",
                "mean_depth",
                "principal_curvatures",
                "principal_curvatures_log",
                "hsv",
            ],
            delta_thresholds={
                "on_object": 0,
                "distance": 0.01,
            },
            surf_agent_sm=True,
            save_raw_obs=False,
        ),
    )
    if not color:
        out["sensor_module_args"]["features"].remove("hsv")

    return out


def get_view_finder_config() -> dict:
    """Get default view finder sensor module config for evaluation.

    The view finder sensor module is used to log detailed observations during
    evaluation. It uses the DetailedLoggingSM class with minimal configuration - just
    setting the sensor module ID and disabling raw observation saving.

    Returns:
        dict: Configuration dictionary containing:
            - sensor_module_class: The DetailedLoggingSM class
            - sensor_module_args: Dict with sensor_module_id and save_raw_obs settings
    """
    return dict(
        sensor_module_class=DetailedLoggingSM,
        sensor_module_args=dict(
            sensor_module_id="view_finder",
            save_raw_obs=False,
        ),
    )


def get_dist_motor_config() -> MotorSystemConfigInformedGoalStateDriven:
    """Get default distant motor config for evaluation.

    Returns:
        MotorSystemConfigInformedGoalStateDriven: Motor system configuration for
            distant agents that uses goal states to drive actions.
    """
    return MotorSystemConfigInformedGoalStateDriven()


def get_surf_motor_config() -> MotorSystemConfigCurInformedSurfaceGoalStateDriven:
    """Get default surface motor config for evaluation.

    Returns:
        MotorSystemConfigCurInformedSurfaceGoalStateDriven: Motor system configuration
            for surface agents that uses curvature-informed goal states to drive
            actions.
    """
    return MotorSystemConfigCurInformedSurfaceGoalStateDriven()


"""
Functions used for generating experiment variants.
--------------------------------------------------------------------------------
"""


def add_sensor_noise(
    config: dict,
    color: bool = True,
    pose_vectors: float = 2.0,
    hsv: float = 0.1,
    principal_curvatures_log: float = 0.1,
    pose_fully_defined: float = 0.01,
    location: float = 0.002,
) -> None:
    """Add defaultsensor noise to an experiment config in-place.

    Applies noise parameters to all sensor modules except the view finder. The
    `color` parameter controls whether to add 'hsv' noise. Set this to `False` for
    touch experiments and experiments using the pretrained touch model.

    Args:
        config: Experiment config to add sensor noise to.

    Returns:
        None: Modifies the input config in-place.
    """
    noise_params = {
        "pose_vectors": pose_vectors,
        "hsv": hsv,
        "principal_curvatures_log": principal_curvatures_log,
        "pose_fully_defined": pose_fully_defined,
        "location": location,
    }
    if not color:
        noise_params.pop("hsv")

    for sm_dict in config["monty_config"].sensor_module_configs.values():
        sm_args = sm_dict["sensor_module_args"]
        if sm_args["sensor_module_id"] == "view_finder":
            continue
        sm_args["noise_params"] = noise_params


def make_noise_variant(template: dict, color: bool = True) -> dict:
    """Duplicate an experiment config with added sensor noise.

    Args:
        template: Experiment config to copy.

    Returns:
        dict: Copy of `template` with added sensor noise and with the
          "_noise" suffix appended to the logging config's `run_name`.

    Raises:
        ValueError: If experiment config does not have a run name.

    """
    config = copy.deepcopy(template)
    run_name = config["logging_config"].run_name
    if not run_name:
        raise ValueError("Experiment must have a run name to make a noisy version.")

    config["logging_config"].run_name = f"{run_name}_noise"
    add_sensor_noise(config, color=color)

    return config


def make_randrot_variant(template: dict) -> dict:
    """Duplicate an experiment config with random object rotations.

    Args:
        template: Experiment config to copy.

    Returns:
        dict: Copy of `template` with a random rotation object initializer and the
          "_randrot" suffix appended to the logging config's `run_name`.

    Raises:
        ValueError: If experiment config does not have a run name.
    """
    config = copy.deepcopy(template)
    run_name = config["logging_config"].run_name
    if not run_name:
        raise ValueError(
            "Experiment must have a run name to make a random rotation version."
        )
    config["logging_config"].run_name = f"{run_name}_randrot"
    config[
        "eval_dataloader_args"
    ].object_init_sampler = RandomRotationObjectInitializer()

    return config


def make_randrot_noise_variant(template: dict, color: bool = True) -> dict:
    """Creates a variant of an experiment with both random rotations and sensor noise.

    Args:
        template: Dictionary containing experiment configuration.
        noise_params: Dictionary of noise parameters to add to sensor modules.
            Defaults to DEFAULT_NOISE_PARAMS.
        color: Whether to add noise to color features. Defaults to True.

    Returns:
        dict: Copy of `template` with sensor noise and a random rotation object
            initializer. The logging config's `run_name` has the original run name
            plus the suffix "_randrot_noise".
    """
    run_name = template["logging_config"].run_name
    config = make_randrot_variant(template)
    config = make_noise_variant(config, color=color)
    config["logging_config"].run_name = f"{run_name}_randrot_noise"

    return config


def make_10distinctobj_variant(template: dict) -> dict:
    """Make 10 distinct object variants for a given config.

    NOTE: We aren't likely to use any 10distinctobj variants in the DMC paper,
    so this will be removed soon. For the time being, it can be useful to
    sometimes test models on the 10-distinctobj dataset for debugging purposes.

    TODO: Remove this function when bringing this code into a publishable state.

    Args:
        template: Experiment config to copy.

    Returns:
        dict: Copy of `template` that evaluates on the DISTINCT_OBJECTS dataset.
            The logging config's `run_name` is appended with "_10distinctobj",

    """
    config = copy.deepcopy(template)
    run_name = template["logging_config"].run_name + "_10distinctobj"
    config["logging_config"].run_name = run_name
    config["eval_dataloader_args"].object_names = DISTINCT_OBJECTS
    return config


"""
------------------------------------------------------------------------------
1 LM models
------------------------------------------------------------------------------
"""

dist_agent_1lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "dist_agent_1lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_1lm"),
    monty_config=PatchAndViewMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        sensor_module_configs=dict(
            sensor_module_0=get_dist_patch_config(),
            sensor_module_1=get_view_finder_config(),
        ),
        learning_module_configs=dict(
            learning_module_0=get_dist_evidence_lm_config(),
        ),
        motor_system_config=get_dist_motor_config(),
    ),
    # Set up environment.
    dataset_class=ED.EnvironmentDataset,
    dataset_args=PatchViewFinderMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

touch_agent_1lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "touch_agent_1lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="touch_agent_1lm"),
    monty_config=SurfaceAndViewMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        sensor_module_configs=dict(
            sensor_module_0=get_surf_patch_config(color=False),
            sensor_module_1=get_view_finder_config(),
        ),
        learning_module_configs=dict(
            learning_module_0=get_surf_evidence_lm_config(color=False),
        ),
        motor_system_config=get_surf_motor_config(),
    ),
    dataset_class=ED.EnvironmentDataset,
    dataset_args=SurfaceViewFinderMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

# Noisy/random rotation variants
# ------------------------------------------------------------------------------

dist_agent_1lm_noise = make_noise_variant(dist_agent_1lm)
dist_agent_1lm_randrot = make_randrot_variant(dist_agent_1lm)
dist_agent_1lm_randrot_noise = make_randrot_noise_variant(dist_agent_1lm)

touch_agent_1lm_noise = make_noise_variant(touch_agent_1lm, color=False)
touch_agent_1lm_randrot = make_randrot_variant(touch_agent_1lm)
touch_agent_1lm_randrot_noise = make_randrot_noise_variant(touch_agent_1lm, color=False)

"""
------------------------------------------------------------------------------
Non-Hypothesis-Driven Policies
------------------------------------------------------------------------------
"""

dist_agent_1lm_nohyp = copy.deepcopy(dist_agent_1lm)
dist_agent_1lm_nohyp["logging_config"].run_name = "dist_agent_1lm_nohyp"
dist_agent_1lm_nohyp[
    "monty_config"
].motor_system_config.motor_system_args.use_goal_state_driven_actions = False

dist_agent_1lm_nohyp_noise = make_noise_variant(dist_agent_1lm_nohyp)
dist_agent_1lm_nohyp_randrot = make_randrot_variant(dist_agent_1lm_nohyp)
dist_agent_1lm_nohyp_randrot_noise = make_randrot_noise_variant(dist_agent_1lm_nohyp)


"""
------------------------------------------------------------------------------
Multimodal transfer
------------------------------------------------------------------------------
"""

touch_on_dist = copy.deepcopy(touch_agent_1lm)
touch_on_dist["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "dist_agent_1lm/pretrained"
)
touch_on_dist["logging_config"].run_name = "touch_on_dist"

touch_on_surf = copy.deepcopy(touch_agent_1lm)
touch_on_surf["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "surf_agent_1lm/pretrained"
)
touch_on_surf["logging_config"].run_name = "touch_on_surf"

# Trained on touch agent. Have to remove hsv feature from sensors and learning modules.
dist_on_touch = copy.deepcopy(dist_agent_1lm)
dist_on_touch["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "touch_agent_1lm/pretrained"
)
dist_on_touch["logging_config"].run_name = "dist_on_touch"
dist_on_touch["monty_config"].sensor_module_configs["sensor_module_0"] = (
    get_dist_patch_config(color=False)
)
dist_on_touch["monty_config"].learning_module_configs["learning_module_0"] = (
    get_dist_evidence_lm_config(color=False)
)

# Noisy/random rotation variants
# ------------------------------------------------------------------------------

touch_on_dist_noise = make_noise_variant(touch_on_dist, color=False)
touch_on_dist_randrot = make_randrot_variant(touch_on_dist)
touch_on_dist_randrot_noise = make_randrot_noise_variant(touch_on_dist, color=False)

dist_on_touch_noise = make_noise_variant(dist_on_touch, color=False)
dist_on_touch_randrot = make_randrot_variant(dist_on_touch)
dist_on_touch_randrot_noise = make_randrot_noise_variant(dist_on_touch, color=False)

"""
------------------------------------------------------------------------------
2 LM models
------------------------------------------------------------------------------
"""

# dist_agent_2lm = dict(
#     experiment_class=MontyObjectRecognitionExperiment,
#     experiment_args=EvalExperimentArgs(
#         model_name_or_path=str(PRETRAIN_DIR / "dist_agent_2lm/pretrained"),
#         n_eval_epochs=len(TEST_ROTATIONS),
#         max_total_steps=MAX_TOTAL_STEPS,
#         max_eval_steps=MAX_EVAL_STEPS,
#         min_lms_match=1,
#     ),
#     logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_2lm"),
#     monty_config=TwoLMMontyConfig(
#         monty_class=MontyForEvidenceGraphMatching,
#         monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
#         learning_module_configs=dict(
#             learning_module_0=get_dist_evidence_lm_config("patch_0"),
#             learning_module_1=get_dist_evidence_lm_config("patch_1"),
#         ),
#         sensor_module_configs=dict(
#             sensor_module_0=get_dist_patch_config("patch_0"),
#             sensor_module_1=get_dist_patch_config("patch_1"),
#             sensor_module_2=get_view_finder_config(),
#         ),
#         motor_system_config=get_dist_motor_config(),
#     ),
#     # Set up environment.
#     dataset_class=ED.EnvironmentDataset,
#     dataset_args=TwoLMMountHabitatDatasetArgs(),
#     eval_dataloader_class=ED.InformedEnvironmentDataLoader,
#     eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
#         object_names=SHUFFLED_YCB_OBJECTS,
#         object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
#     ),
# )

# dist_agent_2lm_noise = make_noise_variant(dist_agent_2lm)
# dist_agent_2lm_randrot = make_randrot_variant(dist_agent_2lm)
# dist_agent_2lm_randrot_noise = make_randrot_noise_variant(dist_agent_2lm)

# """
# ------------------------------------------------------------------------------
# 5-LM models
# ------------------------------------------------------------------------------
# """
# dist_agent_5lm = dict(
#     experiment_class=MontyObjectRecognitionExperiment,
#     experiment_args=EvalExperimentArgs(
#         model_name_or_path=str(PRETRAIN_DIR / "dist_agent_5lm/pretrained"),
#         n_eval_epochs=len(TEST_ROTATIONS),
#         max_total_steps=MAX_TOTAL_STEPS,
#         max_eval_steps=MAX_EVAL_STEPS,
#         min_lms_match=3,
#     ),
#     logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_5lm"),
#     monty_config=FiveLMMontyConfig(
#         monty_class=MontyForEvidenceGraphMatching,
#         monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
#         learning_module_configs=dict(
#             learning_module_0=get_dist_evidence_lm_config("patch_0"),
#             learning_module_1=get_dist_evidence_lm_config("patch_1"),
#             learning_module_2=get_dist_evidence_lm_config("patch_2"),
#             learning_module_3=get_dist_evidence_lm_config("patch_3"),
#             learning_module_4=get_dist_evidence_lm_config("patch_4"),
#         ),
#         sensor_module_configs=dict(
#             sensor_module_0=get_dist_patch_config("patch_0"),
#             sensor_module_1=get_dist_patch_config("patch_1"),
#             sensor_module_2=get_dist_patch_config("patch_2"),
#             sensor_module_3=get_dist_patch_config("patch_3"),
#             sensor_module_4=get_dist_patch_config("patch_4"),
#             sensor_module_5=get_view_finder_config(),
#         ),
#         motor_system_config=get_dist_motor_config(),
#     ),
#     # Set up environment.
#     dataset_class=ED.EnvironmentDataset,
#     dataset_args=FiveLMMountHabitatDatasetArgs(),
#     eval_dataloader_class=ED.InformedEnvironmentDataLoader,
#     eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
#         object_names=SHUFFLED_YCB_OBJECTS,
#         object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
#     ),
# )

# dist_agent_5lm_noise = make_noise_variant(dist_agent_5lm)
# dist_agent_5lm_randrot = make_randrot_variant(dist_agent_5lm)
# dist_agent_5lm_randrot_noise = make_randrot_noise_variant(dist_agent_5lm)


# """
# 9 LM models
# --------------------------------------------------------------------------------
# """
# dist_agent_9lm = dict(
#     experiment_class=MontyObjectRecognitionExperiment,
#     experiment_args=EvalExperimentArgs(
#         model_name_or_path=str(PRETRAIN_DIR / "dist_agent_9lm/pretrained"),
#         n_eval_epochs=len(TEST_ROTATIONS),
#         max_total_steps=MAX_TOTAL_STEPS,
#         max_eval_steps=MAX_EVAL_STEPS,
#         min_lms_match=3,
#     ),
#     logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_9lm"),
#     monty_config=NineLMMontyConfig(
#         monty_class=MontyForEvidenceGraphMatching,
#         monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
#         learning_module_configs=dict(
#             learning_module_0=get_dist_evidence_lm_config("patch_0"),
#             learning_module_1=get_dist_evidence_lm_config("patch_1"),
#             learning_module_2=get_dist_evidence_lm_config("patch_2"),
#             learning_module_3=get_dist_evidence_lm_config("patch_3"),
#             learning_module_4=get_dist_evidence_lm_config("patch_4"),
#             learning_module_5=get_dist_evidence_lm_config("patch_5"),
#             learning_module_6=get_dist_evidence_lm_config("patch_6"),
#             learning_module_7=get_dist_evidence_lm_config("patch_7"),
#             learning_module_8=get_dist_evidence_lm_config("patch_8"),
#         ),
#         sensor_module_configs=dict(
#             sensor_module_0=get_dist_patch_config("patch_0"),
#             sensor_module_1=get_dist_patch_config("patch_1"),
#             sensor_module_2=get_dist_patch_config("patch_2"),
#             sensor_module_3=get_dist_patch_config("patch_3"),
#             sensor_module_4=get_dist_patch_config("patch_4"),
#             sensor_module_5=get_dist_patch_config("patch_5"),
#             sensor_module_6=get_dist_patch_config("patch_6"),
#             sensor_module_7=get_dist_patch_config("patch_7"),
#             sensor_module_8=get_dist_patch_config("patch_8"),
#             sensor_module_9=get_view_finder_config(),
#         ),
#         motor_system_config=get_dist_motor_config(),
#     ),
#     # Set up environment.
#     dataset_class=ED.EnvironmentDataset,
#     dataset_args=NineLMMountHabitatDatasetArgs(),
#     eval_dataloader_class=ED.InformedEnvironmentDataLoader,
#     eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
#         object_names=SHUFFLED_YCB_OBJECTS,
#         object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
#     ),
# )

# dist_agent_9lm_noise = make_noise_variant(dist_agent_9lm)
# dist_agent_9lm_randrot = make_randrot_variant(dist_agent_9lm)
# dist_agent_9lm_randrot_noise = make_randrot_noise_variant(dist_agent_9lm)

# """
# 10 LM models
# --------------------------------------------------------------------------------
# """
# dist_agent_10lm = dict(
#     experiment_class=MontyObjectRecognitionExperiment,
#     experiment_args=EvalExperimentArgs(
#         model_name_or_path=str(PRETRAIN_DIR / "dist_agent_10lm/pretrained"),
#         n_eval_epochs=len(TEST_ROTATIONS),
#         max_total_steps=MAX_TOTAL_STEPS,
#         max_eval_steps=MAX_EVAL_STEPS,
#         min_lms_match=3,
#     ),
#     logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_10lm"),
#     monty_config=TenLMMontyConfig(
#         monty_class=MontyForEvidenceGraphMatching,
#         monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
#         learning_module_configs=dict(
#             learning_module_0=get_dist_evidence_lm_config("patch_0"),
#             learning_module_1=get_dist_evidence_lm_config("patch_1"),
#             learning_module_2=get_dist_evidence_lm_config("patch_2"),
#             learning_module_3=get_dist_evidence_lm_config("patch_3"),
#             learning_module_4=get_dist_evidence_lm_config("patch_4"),
#             learning_module_5=get_dist_evidence_lm_config("patch_5"),
#             learning_module_6=get_dist_evidence_lm_config("patch_6"),
#             learning_module_7=get_dist_evidence_lm_config("patch_7"),
#             learning_module_8=get_dist_evidence_lm_config("patch_8"),
#             learning_module_9=get_dist_evidence_lm_config("patch_9"),
#         ),
#         sensor_module_configs=dict(
#             sensor_module_0=get_dist_patch_config("patch_0"),
#             sensor_module_1=get_dist_patch_config("patch_1"),
#             sensor_module_2=get_dist_patch_config("patch_2"),
#             sensor_module_3=get_dist_patch_config("patch_3"),
#             sensor_module_4=get_dist_patch_config("patch_4"),
#             sensor_module_5=get_dist_patch_config("patch_5"),
#             sensor_module_6=get_dist_patch_config("patch_6"),
#             sensor_module_7=get_dist_patch_config("patch_7"),
#             sensor_module_8=get_dist_patch_config("patch_8"),
#             sensor_module_9=get_dist_patch_config("patch_9"),
#             sensor_module_10=get_view_finder_config(),
#         ),
#         motor_system_config=get_dist_motor_config(),
#     ),
#     # Set up environment.
#     dataset_class=ED.EnvironmentDataset,
#     dataset_args=TenLMMountHabitatDatasetArgs(),
#     eval_dataloader_class=ED.InformedEnvironmentDataLoader,
#     eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
#         object_names=SHUFFLED_YCB_OBJECTS,
#         object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
#     ),
# )

# dist_agent_10lm_noise = make_noise_variant(dist_agent_10lm)
# dist_agent_10lm_randrot = make_randrot_variant(dist_agent_10lm)
# dist_agent_10lm_randrot_noise = make_randrot_noise_variant(dist_agent_10lm)


"""
------------------------------------------------------------------------------
Finalize configs
------------------------------------------------------------------------------
"""


CONFIGS = {
    # 1 LM models
    "dist_agent_1lm": dist_agent_1lm,
    "touch_agent_1lm": touch_agent_1lm,
    # - noise and randrot versions
    "dist_agent_1lm_noise": dist_agent_1lm_noise,
    "dist_agent_1lm_randrot": dist_agent_1lm_randrot,
    "dist_agent_1lm_randrot_noise": dist_agent_1lm_randrot_noise,
    "touch_agent_1lm_noise": touch_agent_1lm_noise,
    "touch_agent_1lm_randrot": touch_agent_1lm_randrot,
    "touch_agent_1lm_randrot_noise": touch_agent_1lm_randrot_noise,
    # Non-hypothesis-driven policies
    "dist_agent_1lm_nohyp": dist_agent_1lm_nohyp,
    "dist_agent_1lm_nohyp_noise": dist_agent_1lm_nohyp_noise,
    "dist_agent_1lm_nohyp_randrot": dist_agent_1lm_nohyp_randrot,
    "dist_agent_1lm_nohyp_randrot_noise": dist_agent_1lm_nohyp_randrot_noise,
    # Multimodal transfer
    "touch_on_dist": touch_on_dist,
    "dist_on_touch": dist_on_touch,
    # - noise and randrot versions
    "touch_on_dist_noise": touch_on_dist_noise,
    "touch_on_dist_randrot": touch_on_dist_randrot,
    "touch_on_dist_randrot_noise": touch_on_dist_randrot_noise,
    "dist_on_touch_noise": dist_on_touch_noise,
    "dist_on_touch_randrot": dist_on_touch_randrot,
    "dist_on_touch_randrot_noise": dist_on_touch_randrot_noise,
    # Multi-LM models
}

"""
Finalize configs
"""

# Perform final checks and attribute assignments.
_output_paths = []
for key, exp in CONFIGS.items():
    # Configure logging.
    exp["logging_config"].output_dir = str(RESULTS_DIR)
    exp["logging_config"].python_log_level = PYTHON_LOG_LEVEL
    exp["logging_config"].wandb_group = WANDB_GROUP
    if not LOG_WANDB:
        exp["logging_config"].wandb_handlers = []

    # Configure dummy train dataloader. Required but not used.
    exp["train_dataloader_class"] = ED.InformedEnvironmentDataLoader
    exp["train_dataloader_args"] = EnvironmentDataloaderPerObjectArgs(
        object_names=["mug"],
        object_init_sampler=PredefinedObjectInitializer(rotations=[[0, 0, 0]]),
    )

    # CHECK: key must match run_name.
    assert key == exp["logging_config"].run_name

    # CHECK: save destination must be unique.
    _path = Path(exp["logging_config"].output_dir) / exp["logging_config"].run_name
    assert _path not in _output_paths
    _output_paths.append(_path)
del _output_paths, _path
